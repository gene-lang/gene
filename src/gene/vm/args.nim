import tables, sets
import ../types

proc resolve_property_instance(scope: Scope): Value =
  if scope.is_nil or scope.tracker.is_nil:
    return NIL
  let selfKey = "self".to_key()
  if scope.tracker.mappings.hasKey(selfKey):
    let idx = scope.tracker.mappings[selfKey]
    if idx.int < scope.members.len:
      return scope.members[idx.int]
  NIL

proc assign_property_params*(matcher: RootMatcher, scope: Scope, explicit_instance: Value = NIL) =
  ## Assign shorthand property parameters (e.g. [/x]) directly onto the instance.
  if matcher.is_nil or scope.is_nil or matcher.children.len == 0:
    return

  var instance = explicit_instance
  if instance == NIL:
    instance = resolve_property_instance(scope)

  if instance.kind != VkInstance:
    return

  for i, param in matcher.children:
    if param.is_prop and i < scope.members.len:
      let value = scope.members[i]
      if value.kind != VkNil:
        instance_props(instance)[param.name_key] = value

# Forward declaration for original process_args function
proc process_args*(matcher: RootMatcher, args: Value, scope: Scope)

template is_simple_positional(matcher: RootMatcher, arg_count: int): bool =
  matcher.hint_mode == MhSimpleData and matcher.children.len == arg_count

template ensure_scope_capacity(scope: Scope, count: int) =
  while scope.members.len < count:
    scope.members.add(NIL)

proc key_to_name(key: Key): string {.inline.} =
  try:
    result = cast[Value](key).str
  except CatchableError:
    result = "<keyword>"

proc process_args_core(matcher: RootMatcher, positional: ptr UncheckedArray[Value],
                      pos_count: int, keywords: seq[(Key, Value)],
                      scope: Scope) {.inline.} =
  ## Shared argument binding logic for positional/keyword combinations.
  while scope.members.len < matcher.children.len:
    scope.members.add(NIL)
  for i in 0..<matcher.children.len:
    scope.members[i] = NIL

  var used_param_indices = initHashSet[int]()
  var used_keys = initHashSet[Key]()
  var prop_splat_index = -1

  if keywords.len > 0:
    var kw_table = initTable[Key, Value]()
    for (k, v) in keywords:
      kw_table[k] = v

    for i, param in matcher.children:
      if (param.kind == MatchProp or param.is_prop) and kw_table.hasKey(param.name_key):
        scope.members[i] = kw_table[param.name_key]
        used_param_indices.incl(i)
        used_keys.incl(param.name_key)

  var pos_index = 0
  var has_value_splat = false
  for i, param in matcher.children:
    if i in used_param_indices:
      continue

    let is_prop_param = param.kind == MatchProp or param.is_prop
    if is_prop_param:
      if param.is_splat:
        if prop_splat_index < 0:
          prop_splat_index = i
      elif param.has_default():
        scope.members[i] = param.default_value
      elif param.required():
        let name = key_to_name(param.name_key)
        raise new_exception(types.Exception, "Missing keyword argument: " & name)
      continue

    if param.is_splat:
      let rest_array = new_array_value()
      while pos_index < pos_count:
        array_data(rest_array).add(positional[pos_index])
        pos_index.inc()
      scope.members[i] = rest_array
      has_value_splat = true
    elif pos_index < pos_count:
      scope.members[i] = positional[pos_index]
      pos_index.inc()
    elif param.has_default():
      scope.members[i] = param.default_value
    elif param.required():
      raise new_exception(types.Exception, "Expected " & $(i + 1) & " arguments, got " & $pos_count)

  if prop_splat_index >= 0:
    var rest_map = new_map_value()
    if keywords.len > 0:
      for (k, v) in keywords:
        if k notin used_keys:
          map_data(rest_map)[k] = v
    scope.members[prop_splat_index] = rest_map

  if not has_value_splat and pos_index < pos_count:
    raise new_exception(types.Exception, "Expected " & $pos_index & " arguments, got " & $pos_count)

  assign_property_params(matcher, scope)

# Optimized version for zero arguments
proc process_args_zero*(matcher: RootMatcher, scope: Scope) {.inline.} =
  ## Ultra-fast path for zero-argument functions
  if matcher.is_simple_positional(0):
    return
  process_args_core(matcher, cast[ptr UncheckedArray[Value]](nil), 0, @[], scope)

# Optimized version for single argument
proc process_args_one*(matcher: RootMatcher, arg: Value, scope: Scope) {.inline.} =
  ## Ultra-fast path for single-argument functions
  if matcher.is_simple_positional(1):
    ensure_scope_capacity(scope, 1)
    scope.members[0] = arg
    return
  var arr = [arg]
  process_args_core(matcher, cast[ptr UncheckedArray[Value]](arr[0].addr), 1, @[], scope)

proc process_args_direct*(matcher: RootMatcher, args: ptr UncheckedArray[Value],
                         arg_count: int, has_keyword_args: bool, scope: Scope) {.inline.} =
  ## Process arguments directly from stack to scope
  ## Supports positional arguments only (keywords handled by process_args_direct_kw).
  if (not has_keyword_args) and matcher.is_simple_positional(arg_count):
    ensure_scope_capacity(scope, arg_count)
    {.push checks: off.}
    var i = 0
    while i < arg_count:
      scope.members[i] = args[i]
      inc i
    {.pop.}
    return

  process_args_core(matcher, args, arg_count, @[], scope)

proc process_args_direct_kw*(matcher: RootMatcher, positional: ptr UncheckedArray[Value],
                            pos_count: int, keywords: seq[(Key, Value)],
                            scope: Scope) {.inline.} =
  ## Optimized processing when keyword arguments are provided separately.
  process_args_core(matcher, positional, pos_count, keywords, scope)

proc process_args*(matcher: RootMatcher, args: Value, scope: Scope) =
  ## Process function arguments and bind them to the scope
  ## Handles both positional and named arguments

  if args.kind == VkGene:
    if args.gene.props.len == 0 and matcher.is_simple_positional(args.gene.children.len):
      ensure_scope_capacity(scope, args.gene.children.len)
      {.push checks: off.}
      var i = 0
      while i < args.gene.children.len:
        scope.members[i] = args.gene.children[i]
        inc i
      {.pop.}
      return

    var positional: seq[Value] = @[]
    var keywords: seq[(Key, Value)] = @[]

    positional = args.gene.children
    for k, v in args.gene.props:
      keywords.add((k, v))

    let pos_ptr = if positional.len > 0: cast[ptr UncheckedArray[Value]](positional[0].addr)
                  else: cast[ptr UncheckedArray[Value]](nil)
    process_args_core(matcher, pos_ptr, positional.len, keywords, scope)
  else:
    process_args_core(matcher, cast[ptr UncheckedArray[Value]](nil), 0, @[], scope)
  
