# Tools Module
# Tool registry and all available tools

# Tool Registry
(var TOOLS {})

(fn $ns/get_tools []
  TOOLS
)

(fn $ns/register_tool [name description params handler]
  ((get_tools) .set name {
    ^description description
    ^params params
    ^handler handler
  })
)

(fn $ns/execute_tool [name args]
  (var tool ((get_tools) .get name))
  (if (tool == nil)
    (return {^error #"Unknown tool: #{name}"})
  )
  (try
    (var result (tool/handler args))
    result
  catch *
    {^error #"Tool execution failed: #{$ex/message}"}
  )
)

(fn $ns/build_system_prompt []
  # Static system prompt to avoid iteration issues
  """You are a helpful AI assistant with access to tools.

Available tools:
- get_time: Get the current date and time
- calculate: Evaluate a mathematical expression. Use this for any math calculations.
  Parameters:
    expression: The math expression to evaluate (e.g., '2 + 2', '10 * 5')
- get_weather: Get the current weather for a location
  Parameters:
    location: The city or location to get weather for
- web_search: Search the web using Google Custom Search. Requires GOOGLE_API_KEY and GOOGLE_CSE_ID.
  Parameters:
    query: Search query
    num: Number of results (default 5)
- read_url: Fetch and read content from a URL. Returns plain text extracted from the page.
  Parameters:
    url: The URL to fetch
    max_chars: Maximum characters to return (default 8000)
- create_image: Generate an image using AI. Returns image URLs.
  Parameters:
    prompt: Description of the image to generate

When you need to use a tool, respond with ONLY a JSON object in this exact format:
{"tool": "tool_name", "args": {"param": "value"}}

After receiving a tool result, provide a natural response to the user.
Only use tools when necessary. For general conversation, respond normally.

When displaying images, use HTML img tags instead of markdown links:
<img style="max-width:600px;width:100%" src="IMAGE_URL">"""
)

# ============================================================
# Tool: get_time
# ============================================================
(register_tool "get_time"
  "Get the current date and time"
  {}
  (fn [args]
    {^result ((gene/now) .to_s)}
  )
)

# ============================================================
# Tool: calculate
# ============================================================
(register_tool "calculate"
  "Evaluate a mathematical expression. Use this for any math calculations."
  {^expression "The math expression to evaluate (e.g., '2 + 2', '10 * 5')"}
  (fn [args]
    (var expr (args .get "expression" ""))
    (try
      (var result (eval (parse expr)))
      {^result result/.to_s}
    catch *
      {^error #"Failed to evaluate: #{expr}"}
    )
  )
)

# ============================================================
# Tool: get_weather
# ============================================================
(register_tool "get_weather"
  "Get the current weather for a location"
  {^location "The city or location to get weather for"}
  (fn [args]
    (var location (args .get "location" "Unknown"))
    {^result #"Weather in #{location}: 72°F (22°C), Partly Cloudy. Humidity: 45%"}
  )
)

# ============================================================
# Tool: web_search
# ============================================================
(fn url_encode [input]
  (var out "")
  (var i 0)
  (loop
    (if (i >= input/.length)
      (break)
    )
    (var ch (input .char_at i))
    (var ch_str (input .substr i i))
    (case ch
    when ' '
      (out .append "+")
    when '"'
      (out .append "%22")
    when '#'
      (out .append "%23")
    when '%'
      (out .append "%25")
    when '&'
      (out .append "%26")
    when '+'
      (out .append "%2B")
    when ','
      (out .append "%2C")
    when '/'
      (out .append "%2F")
    when ':'
      (out .append "%3A")
    when ';'
      (out .append "%3B")
    when '<'
      (out .append "%3C")
    when '='
      (out .append "%3D")
    when '>'
      (out .append "%3E")
    when '?'
      (out .append "%3F")
    when '@'
      (out .append "%40")
    when '['
      (out .append "%5B")
    when '\\'
      (out .append "%5C")
    when ']'
      (out .append "%5D")
    when '^'
      (out .append "%5E")
    when '`'
      (out .append "%60")
    when '{'
      (out .append "%7B")
    when '|'
      (out .append "%7C")
    when '}'
      (out .append "%7D")
    else
      (out .append ch_str)
    )
    (i += 1)
  )
  out
)

(register_tool "web_search"
  "Search the web using Google Custom Search. Requires GOOGLE_API_KEY and GOOGLE_CSE_ID."
  {^query "Search query" ^num "Number of results (default 5)"}
  (fn [args]
    (var query (args .get "query" ""))
    (if (query/.length == 0)
      (return {^error "Missing query"})
    )
    (var api_key ($env .get "GOOGLE_API_KEY" ""))
    (var cse_id ($env .get "GOOGLE_CSE_ID" ""))
    (if (api_key/.length == 0)
      (return {^error "Missing GOOGLE_API_KEY"})
    )
    (if (cse_id/.length == 0)
      (return {^error "Missing GOOGLE_CSE_ID"})
    )

    (var num_val (args .get "num" nil))
    (var num 5)
    (if (num_val != nil)
      (try
        (num = (#"#{num_val}" .to_i))
      catch *
        (num = 5)
      )
    )
    (if (num < 1) then (num = 1))
    (if (num > 10) then (num = 10))

    (var q (url_encode query))
    (var url #"https://www.googleapis.com/customsearch/v1?key=#{api_key}&cx=#{cse_id}&q=#{q}&num=#{num}")
    (try
      (var resp (await (http_get url)))
      (if (resp/status != 200)
        (return {^error #"Search request failed with status #{resp/status}"})
      )
      (var data (gene/json/parse resp/body))
      (if (data .contains "error")
        (return {^error ((data/error) .to_json)})
      )
      (var items (data .get "items" []))
      (if (items/.size == 0)
        (return {^result #"No results found for: #{query}"})
      )
      (var result_parts [])
      (var i 1)
      (items .each (fn [item]
        (var title (item .get "title" ""))
        (var link (item .get "link" ""))
        (var snippet (item .get "snippet" ""))
        (result_parts .append #"#{i}. #{title}\n   #{link}\n   #{snippet}")
        (i += 1)
      ))
      {^result (result_parts .join "\n\n")}
    catch *
      {^error #"Search failed: #{$ex/message}"}
    )
  )
)

# ============================================================
# Tool: read_url
# ============================================================
(fn strip_html_tags [html]
  (var text html)
  (fn remove_tag_block [input tag]
    (var open_tag #"<#{tag}")
    (var close_tag #"</#{tag}>")
    (var lower (input .to_lower))
    (var start (lower .index open_tag))
    (loop
      (if (start < 0)
        (break)
      )
      (var end (lower .index close_tag))
      (if ((end < 0) || (end < start))
        (break)
      )
      (var before (if (start > 0) then (input .substr 0 (start - 1)) else ""))
      (var after_start (end + close_tag/.length))
      (var after (if (after_start < input/.length) then (input .substr after_start) else ""))
      (input = #"#{before}#{after}")
      (lower = (input .to_lower))
      (start = (lower .index open_tag))
    )
    input
  )
  (text = (remove_tag_block text "script"))
  (text = (remove_tag_block text "style"))
  (text = (remove_tag_block text "noscript"))
  (var max_iterations 500)
  (var i 0)
  (loop
    (if (i >= max_iterations)
      (break)
    )
    (var start (text .index "<"))
    (if (start < 0)
      (break)
    )
    (var end (text .index ">"))
    (if (end < 0)
      (break)
    )
    (if (end < start)
      (text = #"#{(text .substr 0 (end - 1))}#{(text .substr (end + 1))}")
    else
      (var before (if (start > 0) then (text .substr 0 (start - 1)) else ""))
      (var after (if ((end + 1) < text/.length) then (text .substr (end + 1)) else ""))
      (text = #"#{before}#{after}")
    )
    (i += 1)
  )
  text
)

(register_tool "read_url"
  "Fetch and read content from a URL. Returns plain text extracted from the page."
  {^url "The URL to fetch" ^max_chars "Maximum characters to return (default 8000)"}
  (fn [args]
    (var url (args .get "url" ""))
    (if (url/.length == 0)
      (return {^error "Missing url"})
    )
    (if (((url .starts_with "http://") == false) && ((url .starts_with "https://") == false))
      (return {^error "URL must start with http:// or https://"})
    )

    (var max_chars 8000)
    (var max_chars_val (args .get "max_chars" nil))
    (if (max_chars_val != nil)
      (try
        (max_chars = (#"#{max_chars_val}" .to_i))
      catch *
        (max_chars = 8000)
      )
    )
    (if (max_chars < 100) then (max_chars = 100))
    (if (max_chars > 16000) then (max_chars = 16000))

    (try
      (var resp (await (http_get url)))
      (if (resp/status != 200)
        (return {^error #"Failed to fetch URL: HTTP #{resp/status}"})
      )

      (var content resp/body)
      (var content_type ((resp/headers .get "content-type" "") .to_lower))

      (if ((content_type .index "text/html") >= 0)
        (if (content/.length > max_chars)
          (var extracted (genex/html/extract_text_with_links content url))
          (var text extracted/text)
          (var links extracted/links)
          (if (links/.length > 0)
            (var links_text "")
            (links .each (fn [link]
              (links_text = #"#{links_text}#{link/index}. #{link/text} - #{link/url}\n")
            ))
            (content = #"#{text}\n\nLinks:\n#{links_text}")
          else
            (content = text)
          )
        else
          (content = (strip_html_tags content))
        )
      )
      (if ((content_type .index "text/html") < 0)
        (var process_limit (max_chars * 3))
        (if (content/.length > process_limit)
          (content = (content .substr 0 (process_limit - 1)))
        )
      )

      (if (content/.length > max_chars)
        (content = (content .substr 0 (max_chars - 1)))
        (content = #"#{content}...\n[Truncated]")
      )

      {^result content}
    catch *
      {^error #"Failed to fetch URL: #{$ex/message}"}
    )
  )
)

# ============================================================
# Tool: create_image
# ============================================================
(register_tool "create_image"
  "Generate an image using AI. Returns image URLs."
  {^prompt "Description of the image to generate"}
  (fn [args]
    (var prompt (args .get "prompt" ""))
    (if (prompt/.length == 0)
      (return {^error "Missing prompt"})
    )

    # Get ComfyUI URL from env
    (var comfyui_url ($env .get "COMFYUI_URL" "http://127.0.0.1:8188"))

    # Build workflow JSON for ComfyUI
    (var seed (random_int 2147483647))
    (var workflow {
      ^3 {
        ^class_type "KSampler"
        ^inputs {
          ^cfg 7.0
          ^denoise 1
          ^latent_image ["5" 0]
          ^model ["4" 0]
          ^negative ["7" 0]
          ^positive ["6" 0]
          ^sampler_name "euler"
          ^scheduler "normal"
          ^seed seed
          ^steps 20
        }
      }
      ^4 {
        ^class_type "CheckpointLoaderSimple"
        ^inputs {^ckpt_name "juggernautXL_v9.safetensors"}
      }
      ^5 {
        ^class_type "EmptyLatentImage"
        ^inputs {^batch_size 1 ^height 1024 ^width 1024}
      }
      ^6 {
        ^class_type "CLIPTextEncode"
        ^inputs {^clip ["4" 1] ^text prompt}
      }
      ^7 {
        ^class_type "CLIPTextEncode"
        ^inputs {^clip ["4" 1] ^text ""}
      }
      ^8 {
        ^class_type "VAEDecode"
        ^inputs {^samples ["3" 0] ^vae ["4" 2]}
      }
      ^9 {
        ^class_type "SaveImage"
        ^inputs {^filename_prefix "ComfyUI" ^images ["8" 0]}
      }
    })

    # Queue prompt to ComfyUI
    (var client_id #"gene-tool-#{(random_int 999999)}")
    (var payload {^prompt workflow ^client_id client_id})
    (var json_body payload/.to_json)
    (var escaped_body (json_body .replace "'" "'\\''"))
    (var queue_cmd #"printf '%s' '#{escaped_body}' | curl -s -X POST -H 'Content-Type: application/json' --data-binary @- '#{comfyui_url}/prompt'")

    (var queue_result (system/shell queue_cmd))

    (if (queue_result/exit_code != 0)
      (return {^error "Failed to queue prompt"})
    )

    (var queue_response (gene/json/parse queue_result/output))
    (if (queue_response .contains "error")
      (var err (queue_response .get "error"))
      (var err_msg (if (err .contains "message") then (err .get "message") else "Unknown error"))
      (return {^error err_msg})
    )

    (var prompt_id (queue_response .get "prompt_id" ""))

    # Poll for completion
    (var max_polls 240)
    (var poll_count 0)
    (var completed false)
    (var output_data nil)

    (loop
      (if (poll_count >= max_polls)
        (return {^error "Image generation timed out"})
      )

      (var history_cmd #"curl -s '#{comfyui_url}/history/#{prompt_id}'")
      (var history_result (system/shell history_cmd))

      (if (history_result/exit_code == 0)
        (try
          (var history (gene/json/parse history_result/output))
          (if (history .contains prompt_id)
            (var prompt_data (history .get prompt_id))
            (if ((prompt_data != nil) && (prompt_data .contains "outputs"))
              (output_data = prompt_data)
              (completed = true)
            )
          )
        catch *
          nil
        )
      )

      (if completed
        (break)
      )

      (poll_count = (poll_count + 1))
      (sleep 500)
    )

    # Extract image info
    (try
      (var outputs (output_data .get "outputs" {}))
      (var images [])
      (outputs .each (fn [node_id node_output]
        (if (node_output .contains "images")
          (var node_images (node_output .get "images" []))
          (node_images .each (fn [img]
            (var filename (img .get "filename" ""))
            (var subfolder (img .get "subfolder" ""))
            (var img_type (img .get "type" "output"))
            (images .append {
              ^filename filename
              ^url #"/generated_images?filename=#{filename}&subfolder=#{subfolder}&type=#{img_type}"
            })
          ))
        )
      ))

      (if (images/.size == 0)
        (return {^error "No images in output"})
      )

      (var first_image (images .get 0))
      {
        ^result #"Image generated! View at: #{first_image/url}"
        ^images images
        ^prompt_id prompt_id
      }
    catch *
      {^error #"Failed to extract images: #{$ex/message}"}
    )
  )
)
