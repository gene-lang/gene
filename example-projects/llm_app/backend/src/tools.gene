# Tools Module
# Tool registry and all available tools

# Tool Registry
(var TOOLS {})

(fn $ns/register_tool [name description params handler]
  (TOOLS .set name {
    ^description description
    ^params params
    ^handler handler
  })
)

(fn $ns/execute_tool [name args]
  (var tool (TOOLS .get name))
  (if (tool == nil)
    (return {^error #"Unknown tool: #{name}"})
  )
  (try
    (tool/handler args)
  catch *
    {^error #"Tool execution failed: #{$ex/message}"}
  )
)

(fn $ns/build_system_prompt []
  (var tool_list [])
  (TOOLS .each (fn [name tool]
    (var params_desc "")
    (if (tool/params/.keys/.size > 0)
      (var param_parts [])
      (tool/params .each (fn [pname pdesc]
        (param_parts .append #"    #{pname}: #{pdesc}")
      ))
      (params_desc = (param_parts .join "\n"))
    )
    (if (params_desc/.length > 0)
      (tool_list .append #"- #{name}: #{tool/description}\n  Parameters:\n#{params_desc}")
    else
      (tool_list .append #"- #{name}: #{tool/description}")
    )
  ))
  (var tools_section (tool_list .join "\n"))
  #"""
You are a helpful AI assistant with access to tools.

Available tools:
#{tools_section}

When you need to use a tool, respond with ONLY a JSON object in this exact format:
{"tool": "tool_name", "args": {"param": "value"}}

After receiving a tool result, provide a natural response to the user.
Only use tools when necessary. For general conversation, respond normally.
"""
)

# ============================================================
# Tool: get_time
# ============================================================
(register_tool "get_time"
  "Get the current date and time"
  {}
  (fn [args]
    {^result ((gene/now) .to_s)}
  )
)

# ============================================================
# Tool: calculate
# ============================================================
(register_tool "calculate"
  "Evaluate a mathematical expression. Use this for any math calculations."
  {^expression "The math expression to evaluate (e.g., '2 + 2', '10 * 5')"}
  (fn [args]
    (var expr (args .get "expression" ""))
    (try
      (var result (eval (parse expr)))
      {^result result/.to_s}
    catch *
      {^error #"Failed to evaluate: #{expr}"}
    )
  )
)

# ============================================================
# Tool: get_weather
# ============================================================
(register_tool "get_weather"
  "Get the current weather for a location"
  {^location "The city or location to get weather for"}
  (fn [args]
    (var location (args .get "location" "Unknown"))
    {^result #"Weather in #{location}: 72°F (22°C), Partly Cloudy. Humidity: 45%"}
  )
)

# ============================================================
# Tool: web_search
# ============================================================
(fn url_encode [input]
  (var out "")
  (var i 0)
  (loop
    (if (i >= input/.length)
      (break)
    )
    (var ch (input .char_at i))
    (var ch_str (input .substr i i))
    (case ch
    when ' '
      (out .append "+")
    when '"'
      (out .append "%22")
    when '#'
      (out .append "%23")
    when '%'
      (out .append "%25")
    when '&'
      (out .append "%26")
    when '+'
      (out .append "%2B")
    when ','
      (out .append "%2C")
    when '/'
      (out .append "%2F")
    when ':'
      (out .append "%3A")
    when ';'
      (out .append "%3B")
    when '<'
      (out .append "%3C")
    when '='
      (out .append "%3D")
    when '>'
      (out .append "%3E")
    when '?'
      (out .append "%3F")
    when '@'
      (out .append "%40")
    when '['
      (out .append "%5B")
    when '\\'
      (out .append "%5C")
    when ']'
      (out .append "%5D")
    when '^'
      (out .append "%5E")
    when '`'
      (out .append "%60")
    when '{'
      (out .append "%7B")
    when '|'
      (out .append "%7C")
    when '}'
      (out .append "%7D")
    else
      (out .append ch_str)
    )
    (i += 1)
  )
  out
)

(register_tool "web_search"
  "Search the web using Google Custom Search. Requires GOOGLE_API_KEY and GOOGLE_CSE_ID."
  {^query "Search query" ^num "Number of results (default 5)"}
  (fn [args]
    (var query (args .get "query" ""))
    (if (query/.length == 0)
      (return {^error "Missing query"})
    )
    (var api_key ($env .get "GOOGLE_API_KEY" ""))
    (var cse_id ($env .get "GOOGLE_CSE_ID" ""))
    (if (api_key/.length == 0)
      (return {^error "Missing GOOGLE_API_KEY"})
    )
    (if (cse_id/.length == 0)
      (return {^error "Missing GOOGLE_CSE_ID"})
    )

    (var num_val (args .get "num" nil))
    (var num 5)
    (if (num_val != nil)
      (try
        (num = (#"#{num_val}" .to_i))
      catch *
        (num = 5)
      )
    )
    (if (num < 1) then (num = 1))
    (if (num > 10) then (num = 10))

    (var q (url_encode query))
    (var url #"https://www.googleapis.com/customsearch/v1?key=#{api_key}&cx=#{cse_id}&q=#{q}&num=#{num}")
    (try
      (var resp (await (http_get url)))
      (if (resp/status != 200)
        (return {^error #"Search request failed with status #{resp/status}"})
      )
      (var data (gene/json/parse resp/body))
      (if (data .contains "error")
        (return {^error ((data/error) .to_json)})
      )
      (var items (data .get "items" []))
      (if (items/.size == 0)
        (return {^result #"No results found for: #{query}"})
      )
      (var result_parts [])
      (var i 1)
      (items .each (fn [item]
        (var title (item .get "title" ""))
        (var link (item .get "link" ""))
        (var snippet (item .get "snippet" ""))
        (result_parts .append #"#{i}. #{title}\n   #{link}\n   #{snippet}")
        (i += 1)
      ))
      {^result (result_parts .join "\n\n")}
    catch *
      {^error #"Search failed: #{$ex/message}"}
    )
  )
)

# ============================================================
# Tool: read_url
# ============================================================
(fn strip_html_tags [html]
  (var text html)
  (fn remove_tag_block [input tag]
    (var open_tag #"<#{tag}")
    (var close_tag #"</#{tag}>")
    (var lower (input .to_lower))
    (var start (lower .index open_tag))
    (loop
      (if (start < 0)
        (break)
      )
      (var end (lower .index close_tag))
      (if ((end < 0) || (end < start))
        (break)
      )
      (var before (if (start > 0) then (input .substr 0 (start - 1)) else ""))
      (var after_start (end + close_tag/.length))
      (var after (if (after_start < input/.length) then (input .substr after_start) else ""))
      (input = #"#{before}#{after}")
      (lower = (input .to_lower))
      (start = (lower .index open_tag))
    )
    input
  )
  (text = (remove_tag_block text "script"))
  (text = (remove_tag_block text "style"))
  (text = (remove_tag_block text "noscript"))
  (var max_iterations 500)
  (var i 0)
  (loop
    (if (i >= max_iterations)
      (break)
    )
    (var start (text .index "<"))
    (if (start < 0)
      (break)
    )
    (var end (text .index ">"))
    (if (end < 0)
      (break)
    )
    (if (end < start)
      (text = #"#{(text .substr 0 (end - 1))}#{(text .substr (end + 1))}")
    else
      (var before (if (start > 0) then (text .substr 0 (start - 1)) else ""))
      (var after (if ((end + 1) < text/.length) then (text .substr (end + 1)) else ""))
      (text = #"#{before}#{after}")
    )
    (i += 1)
  )
  text
)

(register_tool "read_url"
  "Fetch and read content from a URL. Returns plain text extracted from the page."
  {^url "The URL to fetch" ^max_chars "Maximum characters to return (default 8000)"}
  (fn [args]
    (var url (args .get "url" ""))
    (if (url/.length == 0)
      (return {^error "Missing url"})
    )
    (if (((url .starts_with "http://") == false) && ((url .starts_with "https://") == false))
      (return {^error "URL must start with http:// or https://"})
    )

    (var max_chars 8000)
    (var max_chars_val (args .get "max_chars" nil))
    (if (max_chars_val != nil)
      (try
        (max_chars = (#"#{max_chars_val}" .to_i))
      catch *
        (max_chars = 8000)
      )
    )
    (if (max_chars < 100) then (max_chars = 100))
    (if (max_chars > 16000) then (max_chars = 16000))

    (try
      (var resp (await (http_get url)))
      (if (resp/status != 200)
        (return {^error #"Failed to fetch URL: HTTP #{resp/status}"})
      )

      (var content resp/body)
      (var content_type ((resp/headers .get "content-type" "") .to_lower))

      (if ((content_type .index "text/html") >= 0)
        (if (content/.length > max_chars)
          (var extracted (genex/html/extract_text_with_links content url))
          (var text extracted/text)
          (var links extracted/links)
          (if (links/.length > 0)
            (var links_text "")
            (links .each (fn [link]
              (links_text = #"#{links_text}#{link/index}. #{link/text} - #{link/url}\n")
            ))
            (content = #"#{text}\n\nLinks:\n#{links_text}")
          else
            (content = text)
          )
        else
          (content = (strip_html_tags content))
        )
      )
      (if ((content_type .index "text/html") < 0)
        (var process_limit (max_chars * 3))
        (if (content/.length > process_limit)
          (content = (content .substr 0 (process_limit - 1)))
        )
      )

      (if (content/.length > max_chars)
        (content = (content .substr 0 (max_chars - 1)))
        (content = #"#{content}...\n[Truncated]")
      )

      {^result content}
    catch *
      {^error #"Failed to fetch URL: #{$ex/message}"}
    )
  )
)
