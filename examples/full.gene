#!/usr/bin/env gene run
# Gene Programming Language - Complete Syntax Reference

# ===== 1. VARIABLES & ASSIGNMENT =====
(var x 10)                    # Declaration
(x = 20)                      # Assignment
(var name "Gene")             # String
(var pi 3.14159)              # Float
(var flag true)               # Boolean
(var nothing nil)             # Nil

# ===== 2. FUNCTIONS =====
# Basic function with no parameters
(fn hello []
  (println "Hello from function!")
)

# Function with parameters
(fn add [a b]
  (a + b)
)

# Multi-expression function with return
(fn fib [n]
  (if (n <= 1)
    (return n)
  )
  ((fib (n - 1)) + (fib (n - 2)))
)

# Recursive function
(fn factorial [n]
  (if (n <= 1)
    1
  else
    (n * (factorial (n - 1)))
  )
)

# ===== 3. CONTROL FLOW =====
# Basic if
(if true
  (println "If works")
)

# If-elif-else
(if (x > 5)
  (println "x is greater than 5")
elif (x == 5)
  (println "x is equal to 5")
else
  (println "x is less than 5")
)

# Nested if
(var a 5)
(var b 10)
(if (a >= 5)
  (if (b <= 10)
    (println "In range")
  )
)

# Loop with break
(var count 0)
(loop
  (if (count >= 3)
    (break)
  )
  (count += 1)
)

# ===== 4. DATA STRUCTURES =====
# Gene Objects - Native Gene data structure
# Pattern: (type ^key1 val1 ^key2 val2 pos1 pos2 ...)
(var point (:Point ^x 10 ^y 20))
(println "Gene object:" point)

# Gene with mixed properties and positional values
(var mixed_gene (:Data ^name "test" ^id 123 "value1" "value2"))
(println "Mixed gene:" mixed_gene)

# Gene with only properties
(var props_only (:Config ^host "localhost" ^port 8080))
(println "Props only:" props_only)

# Gene with only positional values
(var pos_only (:List 1 2 3 4))
(println "Positional only:" pos_only)

# Nested Gene objects
(var nested_gene (:Outer ^inner (:Inner ^value 42) ^name "test"))
(println "Nested gene:" nested_gene)

# Arrays
(var arr [1 2 3 4 5])
(println "Array:" arr)
(println "First element:" arr/0)
(println "Last element:" arr/4)

# Array modification
(arr/0 = 10)
(println "Modified first element:" arr/0)

# Mixed type array
(var mixed [1 "hello" true])

# Nested arrays
(var nested [[1 2] [3 4]])
(println "nested/0/0 =" nested/0/0)

# Array spread
(var a [1 2])
(var b [3 4])
(var combined [a... b...])

# Empty array
(var empty [])

# Maps (keyword keys with ^ prefix)
(var m {^a 1 ^b 2 ^c 3})
(println "Map:" m)
(println "m/a =" m/a)

# Map modification
(m/a = 10)
(println "Modified m/a =" m/a)

# Mixed value types
(var mixed_map {^num 42 ^str "hello" ^bool true})

# Nested maps
(var nested_map {^outer {^inner 123}})
(println "nested/outer/inner =" nested_map/outer/inner)

# Empty map
(var empty_map {})
(empty_map/new = "value")

# ===== 5. ARITHMETIC & LOGIC =====
# Arithmetic operators
(println "5 + 3 =" (5 + 3))
(println "10 - 4 =" (10 - 4))
(println "6 * 7 =" (6 * 7))
(println "15 / 3 =" (15 / 3))
(println "2 + 3 * 4 =" (2 + (3 * 4)))  # Operator precedence

# Comparison operators
(println "10 > 5 =" (10 > 5))
(println "10 <= 10 =" (10 <= 10))
(println "x == 20 =" (x == 20))
(println "x != 5 =" (x != 5))

# Boolean operators
(println "true && false =" (true && false))
(println "true || false =" (true || false))
# (println "!true =" (! true))

# ===== 6. STRINGS =====
(var s "Hello, Gene!")
(println "String length:" s/.length)  # s/.length = (s .length)
(println "Uppercase:" s/.to_upper)
(println "String to int:" ("42" .to_i))
(println "String to int with spaces:" ("  -7  " .to_i))
(println "String append:" ("hello" .append " world"))

# ===== 7. CLASSES & OOP =====
# Basic class with constructor
(class Point
  (.ctor [x y]
    (/x = x)      # Use / for property access in constructor
    (/y = y)      # /y = self/y
  )
  (.fn get_x _
    /x
  )
  (.fn get_y _
    /y
  )
  (.fn distance _
    (sqrt ((/x * /x) + (/y * /y)))
  )
)

# Class instantiation and method calls
(var p (new Point 3 4))
(println "Point x:" p/.get_x)
(println "Point y:" p/.get_y)
(println "Distance from origin:" p/.distance)

# Class with inheritance
(class Animal)
(class Dog < Animal)

# Nested class
(class Outer
  (.ctor [data]
    (/data = data)
  )
  (class Inner        # Outer is like a namespace
    (.fn get_data _
      Outer/data
    )
  )
)

# Class with macro constructor (receives unevaluated symbols)
(class LazyPoint
  (.ctor! [x y]
    (/x = x)      # x and y are unevaluated arguments
    (/y = y)
  )
  (.fn get_x _
    /x
  )
)

# ===== 8. EXCEPTION HANDLING =====
(try
  (1 / 0)
catch *
  (println "Caught division by zero error:" $ex)  # $ex is the exception object
)

# (try
#   ("abc" .to_i)
# catch *
#   (println "Conversion failed")
# )

# ===== 9. ASYNC PROGRAMMING =====
(var result (await (async 42)))

(fn read_file filename
  (gene/io/read_async filename)
)

(var sum_result (await (read_file "tests/fixtures/test.txt")))

# ===== 10. FUNCTIONAL PROGRAMMING =====
# Lambda/anonymous function
(var double (fnx [x] (x * 2)))
(println "Double 5:" (double 5))

# Function composition
(fn quadruple [x]
  (double (double x))
)
(println "Quadruple 3:" (quadruple 3))

# ===== 11. SYMBOLS & KEYWORDS =====
(var status :success)   # :success = (quote success)
(var error :error)
(println "Status == :success:" (status == :success))

# ===== 12. MACROS & METAPROGRAMMING =====
# Macro-like function with unevaluated arguments
(fn debug! [expr]
  (println "DEBUG:" expr)
  ($caller_eval expr)  # Evaluate the expression in the caller's context.
)

# (debug! (5 + 3))                # Prints "DEBUG: (5 + 3)", returns 8

# ===== 13. COMPLEX NESTED STRUCTURES =====
(var data
  [{^type "user" ^id 123 ^name "Alice" ^verified true}
   {^type "post" ^id 456 ^title "Introduction" ^comments 5}
   {^type "comment" ^id 789 ^author "Bob" ^text "Great post!"}]
)

# Process nested data
(for item in data
  (if (item/type == "user")
    (println "User:" item/name)
  elif (item/type == "post")
    (println "Post:" item/title)
  elif (item/type == "comment")
    (println "Comment by" item/author)
  )
)

# ===== 14. IO OPERATIONS =====
(print "Basic print...")
(println "With newline")

# Environment variables
(println "HOME:" $env/HOME)
(println "Program:" $program)

# ===== 15. COLLECTION PROCESSING =====
(var items
  [{^name "apple" ^price 0.5 ^quantity 10}
   {^name "banana" ^price 0.3 ^quantity 5}])

(var total 0)
(for item in items
  (var cost (item/price * item/quantity))
  (total += cost)
  (println item/name ": $" cost)
)
(println "Total cost:" total)

# ===== 16. COMPREHENSIVE CLASS EXAMPLE =====
(class Calculator
  (.ctor []
    (/memory = {})
  )
  (.fn store [key value]
    (/memory/key = value)
  )
  (.fn recall [key]
    /memory/key
  )
  (.fn add [x y]
    (var result (x + y))
    (/.store "last" result)
    result
  )
)

(var calc (new Calculator))
(println "Calculator add 5 + 3:" (calc .add 5 3))
(calc .store "pi" 3.14159)
(println "Calculator recall pi:" (calc .recall "pi"))
(println "Calculator recall last:" (calc .recall "last"))

# ===== 17. METHOD CALLS AND ACCESSORS =====
# Different method call forms
(calc .add 1 2)               # Method call with explicit receiver
(calc/value = 0)              # Property access and assignment

# ===== 18. FINAL COMPLEX EXAMPLE =====
(class API
  (.ctor [base_url]
    (/url = base_url)
    (/cache = {})
  )
  (.fn request [endpoint]
    (var cached /cache/endpoint)
    (if cached
      cached
    else
      (var result (/url .append endpoint))
      (/cache/endpoint = result)
      result
    )
  )
)

(var api (new API "https://api.example.com"))
(println "API request result:" (api .request "/users"))

(println "=== ALL SYNTAX PATTERNS DEMONSTRATED ===")
