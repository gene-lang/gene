# OOP Examples for Gene Language
# This file demonstrates both working and missing OOP features

########################################
# SECTION 1: WORKING FEATURES
########################################

(println "=== SECTION 1: WORKING FEATURES ===")
(println "")

# 1.1 Basic class creation
(println "1.1 Basic class creation:")
(class Animal)
(println Animal)  # Should print something like #<Class Animal>
(println "")

# 1.2 Basic object creation
(println "1.2 Basic object creation:")
(var dog (new Animal))
(println dog)  # Should print something like #<Instance Animal>
(println "")

# 1.3 Multiple classes
(println "1.3 Multiple classes:")
(class Cat)
(class Bird)
(println Cat)
(println Bird)
(println "")

# 1.4 Class inheritance
(println "1.4 Class inheritance:")
(class Vehicle)
(class Car < Vehicle)
(println Car)  # Should show Car as a class
(var my_car (new Car))
(println my_car)  # Should show Car instance
(println "")

# 1.5 Nested class definition
(println "1.5 Nested class definition:")
(class Outer
  (class Inner)
)
(println Outer/Inner)  # Should print Inner class
(var inner_obj (new Outer/Inner))
(println inner_obj)
(println "")

########################################
# SECTION 2: MISSING FEATURES
########################################

(println "=== SECTION 2: MISSING FEATURES ===")
(println "")

# 2.1 Constructor with instance variables
(println "2.1 Constructor with instance variables:")
(class Person
  (.ctor [name age]
    (/name = name)
    (/age = age)
  )
)
(var alice (new Person "Alice" 30))
(println alice/name)  # Should print "Alice"
(println alice/age)   # Should print 30
(println "")

# 2.2 Constructor with parameter shadowing (shorthand)
(println "2.2 Constructor with parameter shadowing:")
(class Point
  (.ctor [/x /y])  # Shorthand: automatically assigns to /x and /y
)
(var p (new Point 10 20))
(println p/x)  # Should print 10
(println p/y)  # Should print 20
(println "")

# 2.3 Methods
(println "2.3 Methods:")
(class Counter
  (.ctor []
    (/count = 0)
  )
  (.fn increment _
    (/count = (+ /count 1))
  )
  (.fn get_count _
    /count
  )
)
(var c (new Counter))
(c .increment)
(c .increment)
(println (c .get_count))  # Should print 2
(println "")

# 2.4 Method with parameters
(println "2.4 Method with parameters:")
(class Calculator
  (.fn add [a b]
    (+ a b)
  )
  (.fn multiply [a b]
    (* a b)
  )
)
(var calc (new Calculator))
(println (calc .add 5 3))       # Should print 8
(println (calc .multiply 4 7))  # Should print 28
(println "")

# 2.5 Method invocation with dot notation
(println "2.5 Method invocation with dot notation:")
(class Greeter
  (.ctor name
    (/name = name)
  )
  (.fn greet _
    (println "Hello, I'm " /name)
  )
)
(var greeter (new Greeter "Bob"))
(println greeter/.greet)  # Dot notation: object/.method
(println "")

# 2.6 Instance variable access
(println "2.6 Instance variable access:")
(class Rectangle
  (.ctor [width height]
    (/width = width)
    (/height = height)
  )
  (.fn area _
    (* /width /height)
  )
)
(var rect (new Rectangle 10 5))
(println rect/width)   # Should print 10
(println rect/height)  # Should print 5
(println (rect .area)) # Should print 50
(println "")

# 2.7 Instance variable assignment from outside
(println "2.7 Instance variable assignment from outside:")
(class Mutable
  (.ctor _
    (/value = 0)
  )
)
(var m (new Mutable))
(println m/value)  # Should print 0
(m/value = 42)
(println m/value)  # Should print 42
(println "")

# 2.8 Inheritance with method override
(println "2.8 Inheritance with method override:")
(class Animal2
  (.fn speak _
    "Some sound"
  )
)
(class Dog2 < Animal2
  (.fn speak _
    "Woof!"
  )
)
(var dog2 (new Dog2))
(println (dog2 .speak))  # Should print "Woof!"
(println "")

# 2.9 Inheritance with method inherited (not overridden)
(println "2.9 Inheritance with method inherited:")
(class Base
  (.fn test _
    "Base.test"
  )
)
(class Derived < Base)
(var d (new Derived))
(println (d .test))  # Should print "Base.test"
(println "")

# 2.10 Super calls
(println "2.10 Super calls:")
(class Parent
  (.fn greet [name]
    (println "Parent says: Hello " name)
  )
)
(class Child < Parent
  (.fn greet [name]
    (super .greet name)
    (println "Child says: Hi " name)
  )
)
(var child (new Child))
(child .greet "World")
# Should print:
# Parent says: Hello World
# Child says: Hi World
(println "")

# 2.11 Inherited constructor
(println "2.11 Inherited constructor:")
(class ParentWithCtor
  (.ctor name
    (/name = name)
  )
)
(class ChildWithCtor < ParentWithCtor)
(var child_obj (new ChildWithCtor "Alice"))
(println child_obj/name)  # Should print "Alice"
(println "")

# 2.12 Namespaced class definition
(println "2.12 Namespaced class definition:")
(ns geometry
  (ns shapes)
)
(class geometry/shapes/Circle)
(println geometry/shapes/Circle)  # Should print Circle class
(println "")

# 2.13 Type checking with .is
(println "2.13 Type checking with .is:")
(class Fruit)
(class Apple < Fruit)
(var apple (new Apple))
(println (apple .is Apple))  # Should print true
(println (apple .is Fruit))  # Should print true
(println (apple .is String)) # Should print false
(println ([] .is Array))     # Should print true
(println "")

# 2.14 Mixins - maybe not a good idea.
(println "2.14 Mixins:")
# (mixin Flyable
#   (.fn fly _
#     (println "Flying!")
#   )
# )
# (class Bird2
#   (include Flyable)
# )
# (var bird (new Bird2))
# (bird .fly)  # Should print "Flying!"
(println "NOT IMPLEMENTED YET")
(println "")

# 2.15 on_extended callback
(println "2.15 on_extended callback:")
# (class Trackable
#   (var /children [])
#   (.on_extended
#     (fnx child
#       (/children .add child)
#     )
#   )
# )
# (class Tracked1 < Trackable)
# (class Tracked2 < Trackable)
# (println Trackable/children/.size)  # Should print 2
(println "NOT IMPLEMENTED YET")
(println "")

# 2.16 Object syntax (singleton objects)
(println "2.16 Object syntax (singleton objects):")
# ($object config
#   (.fn get_version _
#     "1.0.0"
#   )
# )
# (println config/.get_version)  # Should print "1.0.0"
(println "NOT IMPLEMENTED YET")
(println "")

# 2.17 Macro-like methods (receive unevaluated arguments)
(println "2.17 Macro-like methods:")
(class MacroTest
  (.fn normal [a]
    a
  )
  (.fn macro_like! [a]
    a
  )
)
(var b 1)
(var mt (new MacroTest))
(println (mt .normal b))       # Should print 1
(println (mt .macro_like! b))  # Should print b (symbol)
(println "")

# 2.18 Macro constructor (receives unevaluated arguments)
(println "2.18 Macro constructor:")
# (class LazyPoint
#   (.ctor! [x y]
#     (/x = ($caller_eval x))
#     (/y = ($caller_eval y))
#   )
#   (.fn get_x _
#     /x
#   )
# )
# (var a 5)
# (var lp (new! LazyPoint a (+ 3 2)))
# (println (lp .get_x))  # Should print 5
(println "NOT IMPLEMENTED YET")
(println "")

# 2.19 Class variables (static members)
(println "2.19 Class variables (static members):")
# (class Config
#   (var /version "1.0.0")  # Class variable
#   (.fn get_version _
#     Config/version
#   )
# )
# (println Config/version)  # Should print "1.0.0"
# (Config/version = "2.0.0")
# (println Config/version)  # Should print "2.0.0"
(println "NOT IMPLEMENTED YET")
(println "")

# 2.20 Private methods (if supported)
(println "2.20 Private methods:")
# This is a question - does Gene support private methods?
# Possible syntax: (.fn _private_method ...) ?
(println "DESIGN QUESTION")
(println "")

########################################
# SECTION 3: EDGE CASES & COMBINATIONS
########################################

(println "=== SECTION 3: EDGE CASES & COMBINATIONS ===")
(println "")

# 3.1 Deeply nested classes
(println "3.1 Deeply nested classes:")
(class Level1
  (class Level2
    (class Level3)
  )
)
(println Level1/Level2/Level3)
(println "")

# 3.2 Multiple inheritance levels
(println "3.2 Multiple inheritance levels:")
(class GrandParent)
(class Parent2 < GrandParent)
(class Child2 < Parent2)
(var child_instance (new Child2))
(println child_instance)
(println "")

# 3.3 Constructor with no parameters
(println "3.3 Constructor with no parameters:")
# (class Empty
#   (.ctor _)
# )
# (var empty (new Empty))
(println "NOT IMPLEMENTED YET")
(println "")

# 3.4 Method returning self (for chaining)
(println "3.4 Method returning self (for chaining):")
(class Builder
  (.ctor _
    (/value = 0)
  )
  (.fn add [n]
    (/value = (+ /value n))
    self
  )
  (.fn get _
    /value
  )
)
(var builder (new Builder))
(println ((((builder .add 1) .add 2) .add 3) .get))  # Should print 6
(println "")

(println "")
(println "=== END OF OOP EXAMPLES ===")
